import fs from "node:fs";
import path from "node:path";
import { intro, outro, log } from "@clack/prompts";
import pc from "picocolors";

const CONTENT_DIR = path.join(process.cwd(), "content");
const WATCH_MODE = process.argv.includes("--watch");

interface PlaygroundConfig {
  files: Record<string, string>;
  dependencies?: Record<string, string>;
}

/**
 * Scans for demo folders containing index.tsx and styles.module.css with a playgrounds folder,
 * then generates playground files.
 *
 * Expected structure:
 *   demos/
 *     01-demo-name/
 *       index.tsx           (the demo component)
 *       styles.module.css   (the demo styles)
 *       playgrounds/
 *         index.ts          (auto-generated)
 */
function findDemoFolders(dir: string): string[] {
  const demos: string[] = [];

  function walk(currentDir: string) {
    const entries = fs.readdirSync(currentDir, { withFileTypes: true });

    for (const entry of entries) {
      const fullPath = path.join(currentDir, entry.name);

      if (entry.isDirectory()) {
        // Check if this is a demos folder
        if (entry.name === "demos") {
          // Look for numbered demo folders inside
          const demoEntries = fs.readdirSync(fullPath, { withFileTypes: true });
          for (const demoEntry of demoEntries) {
            if (demoEntry.isDirectory()) {
              const demoPath = path.join(fullPath, demoEntry.name);
              const playgroundsPath = path.join(demoPath, "playgrounds");
              const indexPath = path.join(demoPath, "index.tsx");
              const stylesPath = path.join(demoPath, "styles.module.css");

              if (
                fs.existsSync(playgroundsPath) &&
                fs.existsSync(indexPath) &&
                fs.existsSync(stylesPath)
              ) {
                demos.push(demoPath);
              }
            }
          }
        } else {
          walk(fullPath);
        }
      }
    }
  }

  walk(dir);
  return demos;
}

function extractDependencies(code: string): Record<string, string> {
  const deps: Record<string, string> = {};

  // Match import statements
  const importRegex = /import\s+.*?\s+from\s+["']([^"']+)["']/g;
  let match: RegExpExecArray | null = importRegex.exec(code);

  while (match !== null) {
    const pkg = match[1];
    // Skip relative imports and css imports
    if (pkg.startsWith(".") || pkg.endsWith(".css")) {
      match = importRegex.exec(code);
      continue;
    }

    // Get the package name (handle scoped packages)
    const pkgName = pkg.startsWith("@")
      ? pkg.split("/").slice(0, 2).join("/")
      : pkg.split("/")[0];

    // Add with "latest" version
    deps[pkgName] = "latest";
    match = importRegex.exec(code);
  }

  return deps;
}

function escapeTemplateString(str: string): string {
  return str.replace(/\\/g, "\\\\").replace(/`/g, "\\`").replace(/\$/g, "\\$");
}

/**
 * Transforms demo code to playground code by:
 * - Converting named export functions to default export as "App"
 * - Removing "use client" directive
 */
function transformToPlaygroundCode(code: string): string {
  let transformed = code;

  // Remove "use client" directive
  transformed = transformed.replace(/^["']use client["'];?\s*\n/m, "");

  // Convert named export function to default export App
  // Matches: export function ComponentName() { or export function ComponentName({...}) {
  const namedExportRegex = /export function \w+(\([^)]*\))\s*\{/;
  const match = transformed.match(namedExportRegex);

  if (match) {
    transformed = transformed.replace(
      namedExportRegex,
      `export default function App${match[1]} {`,
    );
  }

  return transformed;
}

/**
 * Converts a folder name like "01-basic-presence" to "BasicPresencePlayground"
 */
function toPascalCase(folderName: string): string {
  // Remove leading number prefix (e.g., "01-")
  const withoutPrefix = folderName.replace(/^\d+-/, "");
  // Convert kebab-case to PascalCase and add "Playground" suffix
  return `${withoutPrefix
    .split("-")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join("")}Playground`;
}

function generatePlayground(demoPath: string): string {
  const playgroundsDir = path.join(demoPath, "playgrounds");
  const indexPath = path.join(demoPath, "index.tsx");
  const stylesPath = path.join(demoPath, "styles.module.css");
  const outputPath = path.join(playgroundsDir, "index.ts");

  const demoName = path.basename(demoPath);
  const exportName = toPascalCase(demoName);

  const rawAppCode = fs.readFileSync(indexPath, "utf-8");
  const appCode = transformToPlaygroundCode(rawAppCode);
  const stylesCode = fs.readFileSync(stylesPath, "utf-8");

  const dependencies = extractDependencies(appCode);

  const _config: PlaygroundConfig = {
    files: {
      "/App.tsx": appCode,
      "/styles.module.css": stylesCode,
    },
    dependencies,
  };

  const output = `// Auto-generated by scripts/generate-playgrounds.ts

export const ${exportName} = {
  files: {
    "/App.tsx": \`${escapeTemplateString(appCode)}\`,
    "/styles.module.css": \`${escapeTemplateString(stylesCode)}\`,
  },
};
`;

  fs.writeFileSync(outputPath, output);
  const relativePath = path.relative(process.cwd(), outputPath);
  return relativePath;
}

function generateAll() {
  const startTime = performance.now();

  intro(pc.bgCyan(pc.black(" playgrounds ")));

  const demos = findDemoFolders(CONTENT_DIR);

  if (demos.length === 0) {
    log.warning("No demos found");
    log.info("Expected structure:");
    log.message(pc.gray("  content/*/demos/*/index.tsx"));
    log.message(pc.gray("  content/*/demos/*/styles.module.css"));
    log.message(pc.gray("  content/*/demos/*/playgrounds/"));
    outro("");
    return;
  }

  const generated: string[] = [];

  for (const demoPath of demos) {
    const relativePath = generatePlayground(demoPath);
    generated.push(relativePath);
  }

  // Print results
  for (const filePath of generated) {
    const stats = fs.statSync(filePath);
    const sizeKb = (stats.size / 1024).toFixed(1);
    const displayName = filePath
      .replace(/^content\//, "")
      .replace(/\/playgrounds\/index\.ts$/, "");
    log.success(`${pc.dim(displayName)} ${pc.gray(`(${sizeKb} kB)`)}`);
  }

  const duration = ((performance.now() - startTime) / 1000).toFixed(2);
  outro(pc.green(`${generated.length} playgrounds in ${duration}s`));
}

function watchPlaygrounds() {
  generateAll();

  const demos = findDemoFolders(CONTENT_DIR);
  const watchedDirs = demos.map((demo) => path.join(demo, "playgrounds"));

  // Watch both the playgrounds dir and parent demo dir for changes
  for (const demoPath of demos) {
    const playgroundsDir = path.join(demoPath, "playgrounds");

    // Watch the demo folder for index.tsx and styles.module.css changes
    fs.watch(demoPath, { recursive: false }, (_eventType, filename) => {
      if (filename === "index.tsx" || filename === "styles.module.css") {
        const relativePath = generatePlayground(demoPath);
        const stats = fs.statSync(relativePath);
        const sizeKb = (stats.size / 1024).toFixed(1);
        const displayName = relativePath
          .replace(/^content\//, "")
          .replace(/\/playgrounds\/index\.ts$/, "");
        log.success(`${pc.dim(displayName)} ${pc.gray(`(${sizeKb} kB)`)}`);
      }
    });

    // Also watch playgrounds folder in case files are added there
    if (fs.existsSync(playgroundsDir)) {
      fs.watch(playgroundsDir, { recursive: false }, (_eventType, filename) => {
        if (
          filename &&
          (filename.endsWith(".tsx") || filename.endsWith(".css"))
        ) {
          const relativePath = generatePlayground(demoPath);
          const stats = fs.statSync(relativePath);
          const sizeKb = (stats.size / 1024).toFixed(1);
          const displayName = relativePath
            .replace(/^content\//, "")
            .replace(/\/playgrounds\/index\.ts$/, "");
          log.success(`${pc.dim(displayName)} ${pc.gray(`(${sizeKb} kB)`)}`);
        }
      });
    }
  }

  log.info(pc.dim(`Watching ${watchedDirs.length} directories...`));
}

function main() {
  if (WATCH_MODE) {
    watchPlaygrounds();
  } else {
    generateAll();
  }
}

main();
