---
title: "Mastering Animate Presence"
description: "Motion's AnimatePresence keeps departing elements mounted long enough to animate out. How it works, when to use it, and what breaks."
date: "2026-01-26"
author: "raphael-salaja"
icon: "motion"
---

import { PresenceStatePlayground } from "./demos/01-presence-state/playgrounds";
import { ManualExitPlayground } from "./demos/02-manual-exit/playgrounds";
import { NestedExitsPlayground } from "./demos/03-nested-exits/playgrounds";
import { ModesDemoPlayground } from "./demos/04-modes-demo/playgrounds";
import { Staging } from "../12-principles-of-animation/demos";

When an element leaves the DOM, it's pretty much gone and as a result, there is no way to animate something that no longer exists.

Motion's Animate Presence fixes this. It keeps departing elements mounted long enough to animate out, then removes them. The basic usage is straightforward, wrap conditional content, define `initial`, `animate`, and `exit` states and the component handles the rest.

<Figure>
  <Staging />
  <Caption>An Example of A Component Powered by Animate Presence [^1]</Caption>
</Figure>


The more interesting question is what happens when basic entry and exit animations are not enough. Components that need to know they are leaving. Animations that depend on navigation direction. Parent-child exits that coordinate. This is where the real power lives.

# Reading Presence State

Sometimes a component needs to know it is exiting. Maybe it changes its appearance, disables interactions, or triggers side effects. The [`useIsPresent`](https://motion.dev/docs/react-animate-presence#useispresent) hook provides this information.[^2]

<Playground {...PresenceStatePlayground} />

The hook returns a boolean. True while mounted normally, false during the exit animation. You might use this to disable buttons while a component exits, switch visual states on unmount, or trigger cleanup when departure begins.

One constraint is that `useIsPresent` must be called from a component that is a child of Animate Presence. You cannot inline the hook in the parent where you conditionally render. This is why the demo above uses a separate `Card` component rather than putting the motion element directly inside the conditional.

# Manual Exit Control

Standard exit animations run on a fixed timeline. But some scenarios require manual control. Async cleanup, external animation libraries, or coordinating with systems outside React.

The [`usePresence`](https://motion.dev/docs/react-animate-presence#usepresence) hook returns both the presence state and a `safeToRemove` callback. The component stays mounted until you call it.

<Playground {...ManualExitPlayground} />

The exit animation starts immediately. Your async work runs in parallel. When both the animation finishes and `safeToRemove` is called, the element unmounts. This is how you could save draft content before a modal closes, wait for a network request to complete, or hand control to [GSAP](https://gsap.com/) or other animation libraries for more complex animations.[^3]

# Nested Exits

When a parent Animate Presence removes its children, nested exit animations do not fire by default. The parent wins. Sometimes you want both. A modal fading out while its content items also animate. The `propagate` prop enables this.

<Playground {...NestedExitsPlayground} />

When true, removing the parent, triggers exit animations on both the parent and its nested children. Without it, children vanish instantly when the parent exits. Stuff like this goes unnoticed by many, but adding things like this really separetes people who care about the details from those who don't.

# Modes

The `mode` prop controls timing between entering and exiting elements.

<Playground {...ModesDemoPlayground} /> 

## `sync`

This is where entering and exiting elements animate simultaneously. It's useful for crossfades or when you want to animate both at the same time. You just have to bare in mind that both elements will be visible at the same time so you will have to handle the layouts to avoid conflicts.

## `wait`

Here the exiting element waits for one to finish before the other starts. I use this when I want a more elegant transition between two elements. When I don't want to have both elements visible at the same time. One thing to pay note to is that because one element has to finish before the other can start, the duration of the animation will almost be doubled. So if you want something quicker you might have to mess around with the durations.

## `popLayout`

Using this mode removes exiting elements from document immediately. They become absolutely positioned, allowing surrounding content to reflow. I use this alot when I need elements to be removed fast without layout shifts, so like list reordering, morphing layout animations etc. It's also handy when I need to run calculations on the parents bounds, like if I'm doing an animated width container and need the width of the parent to update quickly, inline with the animation.

# Closing Thoughts

Even though CSS now has `@starting-style` for native exit animations.[^4] Simple transitions no longer need JavaScript. But the patterns in this article do. Reading presence state, manual exit control, directional animations, coordinated nested exits are things that Animate Presence offers that CSS can't at this point in time.

Animate Presence fills the gap between what CSS can handle and what real interfaces need. The component itself is simple, but hopefuly this article has helped you understand how to use it to it's fullest.


[^1]: An example of a component powered by Animate Presence, taken from my [12 Principles of Animation](/12-principles-of-animation) article.

[^2]: Motion's [AnimatePresence documentation](https://motion.dev/docs/react-animate-presence) covers the full API including useIsPresent, usePresence, and usePresenceData.

[^3]: For complex animation sequences outside React's lifecycle, [GSAP](https://gsap.com/) pairs well with manual exit control.

[^4]: MDN's [@starting-style documentation](https://developer.mozilla.org/en-US/docs/Web/CSS/@starting-style) covers the emerging CSS approach to entry animations.
