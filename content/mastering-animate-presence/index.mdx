---
title: "Mastering Animate Presence"
description: "Motion's AnimatePresence keeps departing elements mounted long enough to animate out. How it works, when to use it, and what breaks."
date: "2026-01-12"
author: "raphael-salaja"
icon: "motion"
---

import { PresenceStatePlayground } from "./demos/01-presence-state/playgrounds";
import { ManualExitPlayground } from "./demos/02-manual-exit/playgrounds";
import { NestedExitsPlayground } from "./demos/03-nested-exits/playgrounds";
import { ModesDemoPlayground } from "./demos/04-modes-demo/playgrounds";

When an element leaves the DOM, it's pretty much gone and as a result, there is no way to animate something that no longer exists.

Motion's Animate Presence fixes this. It keeps departing elements mounted long enough to animate out, then removes them. The basic usage is straightforward: wrap conditional content, define `initial`, `animate`, and `exit` states. The component handles the rest.

The more interesting question is what happens when basic entry and exit animations are not enough. Components that need to know they are leaving. Animations that depend on navigation direction. Parent-child exits that coordinate. This is where the real power lives.

Note this article is not a retelling of the documentation. It is a guide to understanding Animate Presence and how to use it effectively.

# Reading Presence State

Sometimes a component needs to know it is exiting. Maybe it changes its appearance, disables interactions, or triggers side effects. The `useIsPresent` hook provides this information.

<Playground {...PresenceStatePlayground} />

The hook returns a boolean. True while mounted normally, false during the exit animation. You might use this to disable buttons while a component exits, switch visual states on unmount, or trigger cleanup when departure begins.

One constraint is that `useIsPresent` must be called from a component that is a child of Animate Presence. You cannot inline the hook in the parent where you conditionally render. This is why the demo above uses a separate `Card` component rather than putting the motion element directly inside the conditional.

# Manual Exit Control

Standard exit animations run on a fixed timeline. But some scenarios require manual control. Async cleanup, external animation libraries, or coordinating with systems outside React.

The `usePresence` hook returns both the presence state and a `safeToRemove` callback. The component stays mounted until you call it.

<Playground {...ManualExitPlayground} />

The exit animation starts immediately. Your async work runs in parallel. When both the animation finishes and `safeToRemove` is called, the element unmounts. This is how you save draft content before a modal closes, wait for a network request to complete, or hand control to GSAP or other animation libraries.

# Nested Exits

When a parent Animate Presence removes its children, nested exit animations do not fire by default. The parent wins. Sometimes you want both. A modal fading out while its content items also animate. The `propagate` prop enables this.

<Playground {...NestedExitsPlayground} />

When true, removing the parent, triggers exit animations on both the parent and its nested children. Without it, children vanish instantly when the parent exits.

# Modes

The `mode` prop controls timing between entering and exiting elements.

<Playground {...ModesDemoPlayground} /> 

## `sync`

This is where entering and exiting elements animate simultaneously. It's useful for crossfades or when you want to animate both at the same time. You just have to bare in mind that both elements will be visible at the same time so you will have to handle the layouts to avoid conflicts.

## `wait`

Here the exiting element wait's for one to finish before the other starts. I use this when I want a more elegant transition between two elements. When I don't want to have both elements visible at the same time. One thing to pay note is that because both one element has to finish before the other can start, the duration of the animation will almost be doubled. So if you want something quicker you might have to mess around with the durations.

## `popLayout`

Using this mode removes exiting elements from document flow immediately. They become absolutely positioned, allowing surrounding content to reflow. I use this alot when I need elements to be removed fast without layout shifts, so like list reordering, morphing layout animations etc. It's also handy when I need to run calculations on the parents bounds, like if I'm doing an animated width container and need the width of the parent to update quickly, inline with the animation.

# Common Pitfalls

## Unstable Keys

Exit animations need stable keys. Array indices don't work because they shift on removal.

```tsx
// Broken: indices shift when items are removed
{items.map((item, index) => (
  <Component key={index} />
))}

// Works: stable IDs persist
{items.map((item) => (
  <Component key={item.id} />
))}
```

React sees the key change as a replacement, not a removal. No exit animation fires.

## AnimatePresence Placement

AnimatePresence cannot animate its own unmount. Keep it mounted and toggle its children instead.

```tsx
// Broken: AnimatePresence unmounts too
{isVisible && (
  <AnimatePresence>
    <Component />
  </AnimatePresence>
)}

// Works: AnimatePresence stays, child leaves
<AnimatePresence>
  {isVisible && <Component />}
</AnimatePresence>
```

## Transform Conflicts

`popLayout` positions exiting elements absolutely. If their parent has a CSS transform, the element positions relative to that transformed ancestor instead of the viewport.

Fix: set `position: relative` on the direct parent to establish the positioning context.

# Initial Mount

By default, content animates in on first mount. To skip this and have content appear settled:

```tsx
<AnimatePresence initial={false}>
  <Content key={activeId} />
</AnimatePresence>
```

# Closing Thoughts

CSS now has `@starting-style` for native exit animations. Simple transitions no longer need JavaScript. But the patterns in this article do: reading presence state, manual exit control, directional animations, coordinated nested exits.

Animate Presence fills the gap between what CSS can handle and what real interfaces need. The component itself is simple. Wrap conditional content, define states, watch elements come and go.

The harder question is when. Not every transition needs animation. Most do not. But when one does, and CSS transitions are not enough, Animate Presence makes the complex cases manageable.

[^1]: For more on when to skip animation entirely, see [To Spring or Not to Spring](/to-spring-or-not-to-spring).
