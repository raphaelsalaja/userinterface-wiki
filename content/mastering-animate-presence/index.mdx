---
title: "Mastering Animate Presence"
description: "Motion's AnimatePresence keeps departing elements mounted long enough to animate out. How it works, when to use it, and what breaks."
date: "2026-01-12"
author: "raphael-salaja"
icon: "motion"
---

import { BasicPresencePlayground } from "./demos/01-basic-presence/playgrounds";
import { SlideshowDemoPlayground } from "./demos/02-slideshow-demo/playgrounds";
import { ListDemoPlayground } from "./demos/03-list-demo/playgrounds";
import { ModesDemoPlayground } from "./demos/04-modes-demo/playgrounds";
import { PresenceStatePlayground } from "./demos/05-presence-state/playgrounds";
import { ManualExitPlayground } from "./demos/06-manual-exit/playgrounds";
import { NestedExitsPlayground } from "./demos/07-nested-exits/playgrounds";

When an element leaves the DOM, it vanishes. No warning, no transition. You cannot animate something that no longer exists.

Motion's Animate Presence fixes this. It keeps departing elements mounted long enough to animate out, then removes them. The basic usage is straightforward: wrap conditional content, define `initial`, `animate`, and `exit` states. The component handles the rest.

<Playground {...BasicPresencePlayground} />

The more interesting question is what happens when basic entry and exit animations are not enough. Components that need to know they are leaving. Animations that depend on navigation direction. Parent-child exits that coordinate. This is where the real power lives.

Note this article is not a retelling of the documentation. It is a guide to understanding Animate Presence and how to use it effectively.

# Reading Presence State

Sometimes a component needs to know it is exiting. Maybe it changes its appearance, disables interactions, or triggers side effects. The `useIsPresent` hook provides this information.

<Playground {...PresenceStatePlayground} />

The hook returns a boolean. True while mounted normally, false during the exit animation. Use cases: switching states on unmount, disabling interactive elements during an exit, or triggering side effects when a component begins leaving.

# Manual Exit Control

Standard exit animations run on a fixed timeline. But some scenarios require manual control. Async cleanup, external animation libraries, or coordinating with systems outside React.

The `usePresence` hook returns both the presence state and a `safeToRemove` callback. The component stays mounted until you call it.

<Playground {...ManualExitPlayground} />

The exit animation starts immediately. Your async work runs in parallel. When both the animation finishes and `safeToRemove` is called, the element unmounts. Use cases: saving draft content before a modal closes, waiting for a network request to complete, coordinating with GSAP or other animation libraries.

# Directional Animations

Exiting components cannot receive new props. React has already scheduled their removal. But Animate Presence accepts a `custom` prop that reaches all children, including those leaving.

This enables directional slideshows. The exit direction matches the navigation direction, even though the exiting slide cannot receive new props directly.

<Playground {...SlideshowDemoPlayground} />

The parent passes direction through `custom`. Children access it with `usePresenceData`. The `custom` value updates for all children, including those mid-exit. Without this, the exiting slide would not know which direction the user navigated.

# Nested Exits

When a parent Animate Presence removes its children, nested exit animations do not fire by default. The parent wins.

Sometimes you want both. A modal fading out while its content items also animate. The `propagate` prop enables this.

<Playground {...NestedExitsPlayground} />

With `propagate={true}`, removing the parent triggers exit animations on both the parent and its nested children. Without it, children vanish instantly when the parent exits.

# Modes

The `mode` prop controls timing between entering and exiting elements.

<Playground {...ModesDemoPlayground} />

**sync** is the default. Entering and exiting elements animate simultaneously. Good for crossfades.

**wait** sequences them. The exiting element finishes before the entering element starts. Good for clear handoffs.

**popLayout** removes exiting elements from document flow immediately. They become absolutely positioned, allowing surrounding content to reflow. Pair this with the `layout` prop for smooth list reordering.

<Playground {...ListDemoPlayground} />

# Common Pitfalls

Three patterns break silently.

## Unstable Keys

Exit animations require stable keys. Array indices fail because they shift on removal.

```tsx
// Broken: indices shift when items are removed
{items.map((item, index) => (
  <Component key={index} />
))}

// Works: stable IDs persist
{items.map((item) => (
  <Component key={item.id} />
))}
```

When you remove the second item from a list of three, indices 1 and 2 become indices 0 and 1. React sees a key change, not a removal. No exit animation fires.

## AnimatePresence Placement

If Animate Presence itself unmounts, it cannot animate anything. Keep it mounted; change its children.

```tsx
// Broken: AnimatePresence unmounts too
{isVisible && (
  <AnimatePresence>
    <Component />
  </AnimatePresence>
)}

// Works: AnimatePresence stays, child leaves
<AnimatePresence>
  {isVisible && <Component />}
</AnimatePresence>
```

## popLayout and Transforms

`popLayout` makes exiting elements absolutely positioned. If their parent has a CSS transform, positioning breaks. The element positions relative to the transformed ancestor, not where you expect.

Set `position: relative` on the direct parent to establish the positioning context.

# Skipping Initial Animations

By default, content wrapped in Animate Presence animates in from the initial state on page load. To skip this first mount animation, pass `initial={false}`:

```tsx
<AnimatePresence initial={false}>
  <Content key={activeId} />
</AnimatePresence>
```

Useful when you want content to appear settled on page load. [^1]

# Closing Thoughts

CSS now has `@starting-style` for native exit animations. Simple transitions no longer need JavaScript. But the patterns in this article do: reading presence state, manual exit control, directional animations, coordinated nested exits.

Animate Presence fills the gap between what CSS can handle and what real interfaces need. The component itself is simple. Wrap conditional content, define states, watch elements come and go.

The harder question is when. Not every transition needs animation. Most do not. But when one does, and CSS transitions are not enough, Animate Presence makes the complex cases manageable.

[^1]: For more on when to skip animation entirely, see [To Spring or Not to Spring](/to-spring-or-not-to-spring).
