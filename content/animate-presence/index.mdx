---
title: "Animate Presence"
description: "Motion's AnimatePresence keeps departing elements mounted long enough to animate out. How it works, when to use it, and what breaks."
date: "2026-01-12"
author: "raphael-salaja"
icon: "motion"
---

import {
  BasicPresence,
  SlideshowDemo,
  ListDemo,
  ModesDemo,
  PresenceState,
} from "./demos";

import { BasicPresencePlayground } from "./demos/01-basic-presence/playgrounds";

When an element leaves the DOM, it vanishes. No warning, no transition. You cannot animate something that no longer exists.

Motion's Animate Presence fixes this. It keeps departing elements mounted long enough to animate out, then removes them. Entrances and exits become declarative. You describe the states, the component handles the timing.

# Mechanics

Animate Presence watches its direct children. When one appears, it animates from `initial` to `animate`. When one disappears, it stays mounted, runs the `exit` animation, then unmounts.

This requires unique `key` props. Without them, there is no way to know which child left.

<Playground {...BasicPresencePlayground} />

`initial` defines where the element starts. `animate` defines where it settles. `exit` defines how it leaves. Each accepts an object or variant label.

A common mistake is using array indices as keys. This breaks exit animations because removing an item shifts all subsequent indices. Use something stable like an ID instead.

# Animate Presence Modes

The mode prop controls timing. Three options: `sync`, `wait`, and `popLayout`.

## sync

## sync 

Both entering and exiting elements animate at the same time. There is no sequencing, no waiting. As soon as an element is added or removed, its animation begins.

## wait

The entering element waits until the exiting element has fully animated out. This creates sequential animations.

## popLayout

Exiting elements are "popped" out of the document flow, allowing surrounding elements to reflow immediately. This pairs exceptionally well with the `layout` prop.


# Accessing Presence State

Sometimes a component needs to know if it's exiting. Motion provides hooks for this.

<Figure>  
  <PresenceState />
  <Caption>Components can read and react to their presence state.</Caption>
</Figure>

## useIsPresent

Returns a boolean. True while mounted, false while exiting.

```tsx
import { useIsPresent } from "motion/react";

function Component() {
  const isPresent = useIsPresent();
  return <div>{isPresent ? "Here!" : "Leaving..."}</div>;
}
```

## usePresence

Returns the presence state and a `safeToRemove` callback. Use this for manual control over removal timing.

```tsx
import { usePresence } from "motion/react";

function Component() {
  const [isPresent, safeToRemove] = usePresence();

  useEffect(() => {
    if (!isPresent) {
      // Do something, then signal we are done
      setTimeout(safeToRemove, 1000);
    }
  }, [isPresent, safeToRemove]);

  return <div />;
}
```

Useful for complex exits with external animations or async cleanup.

## usePresenceData

Exiting components cannot receive new props. But Animate Presence accepts a `custom` prop that reaches all children, including those exiting.

```tsx
<AnimatePresence custom={direction}>
  <Slide key={activeSlideId} />
</AnimatePresence>
```

Inside the child, `usePresenceData` retrieves that value:

```tsx
import { usePresenceData } from "motion/react";

function Slide() {
  const direction = usePresenceData();
  return <motion.div exit={{ x: direction === 1 ? -300 : 300 }} />;
}
```

This enables directional slideshows where exit direction matches navigation direction.

# Nested AnimatePresence

When a parent Animate Presence removes its children, nested exit animations do not fire. The parent wins.

To enable nested exits, set `propagate` to true:

```tsx
<AnimatePresence>
  {show && (
    <motion.section exit={{ opacity: 0 }}>
      <AnimatePresence propagate>
        {children}
      </AnimatePresence>
    </motion.section>
  )}
</AnimatePresence>
```

When `show` becomes false, both exits fire.

# Common Pitfalls

Three patterns break silently.

## Missing or Non-Unique Keys

Exit animations need stable keys. Array indices fail because they shift on removal.

```tsx
// Bad - indices shift on removal
{items.map((item, index) => (
  <Component key={index} />
))}

// Good - stable IDs
{items.map((item) => (
  <Component key={item.id} />
))}
```

## AnimatePresence Outside the Conditional

If Animate Presence unmounts, it cannot animate anything. Keep it mounted, change its children.

```tsx
// Bad - AnimatePresence unmounts too
{isVisible && (
  <AnimatePresence>
    <Component />
  </AnimatePresence>
)}

// Good - AnimatePresence stays, child leaves
<AnimatePresence>
  {isVisible && <Component />}
</AnimatePresence>
```

## Layout Issues with popLayout

`popLayout` makes exiting elements absolutely positioned. If their parent has a `transform`, positioning breaks. Set `position: relative` on the parent.

# The initial Prop

Children present at mount run their `initial` animations by default. Sometimes you want the page to appear settled.

Pass `initial={false}` to skip first-render animations:

```tsx
<AnimatePresence initial={false}>
  <Slide key={activeItem.id} />
</AnimatePresence>
```

Subsequent changes still animate. Only the first render is affected.

# Common Patterns

Most uses of Animate Presence fall into a few categories. Understanding these patterns helps you reach for the right approach faster.

## Conditional Rendering

The simplest case. A component is either shown or hidden, and you want both transitions to feel intentional.

```tsx
<AnimatePresence>
  {isVisible && (
    <motion.div
      key="panel"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
    />
  )}
</AnimatePresence>
```

This works for modals, popovers, alerts, and any UI that toggles on and off. The key remains constant because the same logical element is appearing and disappearing.

## Slideshows and Carousels

When you want to swap between items, changing the `key` is what triggers the transition. React sees a different key and treats it as an entirely new component, prompting Animate Presence to animate the old one out and the new one in.

<Figure>
  <SlideshowDemo />
</Figure>

The entering image slides in from the right while the exiting image slides out to the left. Because both animations run simultaneously by default, you get a seamless crossfade effect.

## Dynamic Lists

Lists introduce more complexity because multiple items can enter and exit at once. Each item needs a stable key that persists across renders.

<Figure>
  <ListDemo />
  <Caption>Items animate in and out of a dynamic list.</Caption>
</Figure>

```tsx
<AnimatePresence>
  {items.map((item) => (
    <motion.li
      key={item.id}
      initial={{ opacity: 0, height: 0 }}
      animate={{ opacity: 1, height: "auto" }}
      exit={{ opacity: 0, height: 0 }}
      layout
    />
  ))}
</AnimatePresence>
```


# Practical Considerations

Exit animations add polish. They also add delay. Every animation is time before the user sees what they expect.

Used thoughtfully, this creates continuity. Overused, it creates friction.

Keep exit animations short. 150 to 250ms is enough. Longer feels sluggish.

Match exit energy to entrance. If something fades in gently, fade it out gently.

Skip entrances for high-frequency interactions. Context menus, tooltips, and dropdowns often feel better appearing instantly. [^1]

The goal is motion that serves the experience without calling attention to itself. Exit animations should feel inevitable, not noticed.

# Closing Thoughts

Animate Presence solves a problem that should not exist. Elements should enter and leave the DOM gracefully without library intervention.

Until CSS or React provides a native solution, this is what we have. The component itself is simple. Wrap conditional content, define states, watch elements come and go.

The harder question is when. Not every transition needs animation. Most do not. But when one does, the alternative is either instant or broken. Animate Presence makes the third option possible.

[^1]: For more on when to skip animation entirely, see [To Spring or Not to Spring](/to-spring-or-not-to-spring).

