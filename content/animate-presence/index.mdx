---
title: "Animate Presence"
description: "Motion's AnimatePresence keeps departing elements mounted long enough to animate out. How it works, when to use it, and what breaks."
date: "2026-01-12"
author: "raphael-salaja"
icon: "motion"
---

import {
  BasicPresence,
  SlideshowDemo,
  ListDemo,
  ModesDemo,
  PresenceState,
} from "./demos";

import { BasicPresencePlayground } from "./demos/01-basic-presence/playgrounds";

When an element leaves the DOM, it vanishes. No warning, no transition. You cannot animate something that no longer exists.

Motion's Animate Presence fixes this. It keeps departing elements mounted long enough to animate out, then removes them. Entrances and exits become declarative. You describe the states, the component handles the timing.

# Mechanics

Animate Presence watches its direct children. When one appears, it animates from `initial` to `animate`. When one disappears, it stays mounted, runs the `exit` animation, then unmounts.

This requires unique `key` props. Without them, there is no way to know which child left.

<Playground {...BasicPresencePlayground} />

`initial` defines where the element starts. `animate` defines where it settles. `exit` defines how it leaves. Each accepts an object or variant label.


# The Mode Prop

The mode prop controls timing. Three options: `sync`, `wait`, and `popLayout`.

## sync

Entrance and exit happen simultaneously. You handle layout conflicts, usually with `position: absolute`. Use this when elements occupy different space.

## wait

Entrance waits for exit to finish. No overlap.

## popLayout

Exiting elements leave the document flow immediately. Surrounding content reflows while the exit animation plays. This works well with layout animations.

<Callout type="info" title="Note">
When using `popLayout`, custom components that are direct children of Animate Presence must forward their ref. This is how Motion knows which DOM node to pop out of flow.
</Callout>

# Accessing Presence State

Sometimes a component needs to know if it's exiting. Motion provides hooks for this.

<Figure>
  <PresenceState />
  <Caption>Components can read and react to their presence state.</Caption>
</Figure>

## useIsPresent

Returns a boolean. True while mounted, false while exiting.

```tsx
import { useIsPresent } from "motion/react";

function Component() {
  const isPresent = useIsPresent();
  return <div>{isPresent ? "Here!" : "Leaving..."}</div>;
}
```

## usePresence

Returns the presence state and a `safeToRemove` callback. Use this for manual control over removal timing.

```tsx
import { usePresence } from "motion/react";

function Component() {
  const [isPresent, safeToRemove] = usePresence();

  useEffect(() => {
    if (!isPresent) {
      // Do something, then signal we are done
      setTimeout(safeToRemove, 1000);
    }
  }, [isPresent, safeToRemove]);

  return <div />;
}
```

Useful for complex exits with external animations or async cleanup.

## usePresenceData

Exiting components cannot receive new props. But Animate Presence accepts a `custom` prop that reaches all children, including those exiting.

```tsx
<AnimatePresence custom={direction}>
  <Slide key={activeSlideId} />
</AnimatePresence>
```

Inside the child, `usePresenceData` retrieves that value:

```tsx
import { usePresenceData } from "motion/react";

function Slide() {
  const direction = usePresenceData();
  return <motion.div exit={{ x: direction === 1 ? -300 : 300 }} />;
}
```

This enables directional slideshows where exit direction matches navigation direction.

# Nested AnimatePresence

When a parent Animate Presence removes its children, nested exit animations do not fire. The parent wins.

To enable nested exits, set `propagate` to true:

```tsx
<AnimatePresence>
  {show && (
    <motion.section exit={{ opacity: 0 }}>
      <AnimatePresence propagate>
        {children}
      </AnimatePresence>
    </motion.section>
  )}
</AnimatePresence>
```

When `show` becomes false, both exits fire.

# Common Pitfalls

Three patterns break silently.

## Missing or Non-Unique Keys

Exit animations need stable keys. Array indices fail because they shift on removal.

```tsx
// Bad - indices shift on removal
{items.map((item, index) => (
  <Component key={index} />
))}

// Good - stable IDs
{items.map((item) => (
  <Component key={item.id} />
))}
```

## AnimatePresence Outside the Conditional

If Animate Presence unmounts, it cannot animate anything. Keep it mounted, change its children.

```tsx
// Bad - AnimatePresence unmounts too
{isVisible && (
  <AnimatePresence>
    <Component />
  </AnimatePresence>
)}

// Good - AnimatePresence stays, child leaves
<AnimatePresence>
  {isVisible && <Component />}
</AnimatePresence>
```

## Layout Issues with popLayout

`popLayout` makes exiting elements absolutely positioned. If their parent has a `transform`, positioning breaks. Set `position: relative` on the parent.

# The initial Prop

Children present at mount run their `initial` animations by default. Sometimes you want the page to appear settled.

Pass `initial={false}` to skip first-render animations:

```tsx
<AnimatePresence initial={false}>
  <Slide key={activeItem.id} />
</AnimatePresence>
```

Subsequent changes still animate. Only the first render is affected.

# Practical Considerations

Exit animations add polish. They also add delay. Every animation is time before the user sees what they expect.

Used thoughtfully, this creates continuity. Overused, it creates friction.

Keep exit animations short. 150 to 250ms is enough. Longer feels sluggish.

Match exit energy to entrance. If something fades in gently, fade it out gently.

Skip entrances for high-frequency interactions. Context menus, tooltips, and dropdowns often feel better appearing instantly. [^1]

The goal is motion that serves the experience without calling attention to itself. Exit animations should feel inevitable, not noticed.

# Closing Thoughts

Animate Presence solves a problem that should not exist. Elements should enter and leave the DOM gracefully without library intervention.

Until CSS or React provides a native solution, this is what we have. The component itself is simple. Wrap conditional content, define states, watch elements come and go.

The harder question is when. Not every transition needs animation. Most do not. But when one does, the alternative is either instant or broken. Animate Presence makes the third option possible.

[^1]: For more on when to skip animation entirely, see [To Spring or Not to Spring](/to-spring-or-not-to-spring).

